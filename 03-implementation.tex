\chapter{Implementation}
\label{cha:imp}
There was a number of considerations while designing and building this solution. These ranged from time limitations to minimising the amount of chances in the original Testu01 library and producing a less complex solution. 

This chapter explains these limitations and the process of making choices in the design of the final implementation in order to best balance the solution between these limitations.

\section{Design Choices}
\subsection{Threads versus Processes}
\label{sec:processes}
The usual approach in parallelisation is to spawn threads, each of which handles a discrete part of the processing. This approach is favoured in larger projects, because it allows handling the complexity of multithreading internally, without the use of process wrappers.

The biggest advantage of threads is that they share address space. Results can be passed to the thread handler via conventional means, such as arrays. Since each test already puts its results in a specific array cell, this approach would seem natural.

Usually, thread programming is bug-prone because of the need for locking. Data corruption, deadlocks and loss of performance due to waiting for locked resources are common\cite{ers-artofunix}. Fixing these would increase overall time required to complete the project.

A multi-threaded Testu01 would not suffer from these problems. The result data of each test is already placed completely independently in an array, so locking would not be required.

However, there is a number of problems with using threads, the greatest of which is that the complexity of the changes in Testu01 would be quite high. 

The creators of Testu01 have in some cases built in it functionality that eases the decoupling of the separate tests in threads. In some others, their code is too tightly integrated together that a multi-threaded approach would require major restructuring. 

The generators are not shareable between threads. There is only one generator that the tests use in sequence. If it were to be used by threads, each thread would not get sequential increments along the generator state, effectively getting random sequences instead of deterministic ones and the test results would be skewed.

Thus the biggest challenge would be to ensure that every thread uses a separate generator. An array of generators could be used, but this would require building a function that using a single generator instance creates an array of them. This would increase complexity and potentially introduce unforeseen consequences. Restructuring the test suites so that they use the generator array would be required. Finally, the way that the result printing aggregators are called and behave would have to change. All these involve restructuring that would both require large amount of time and might introduce unforeseen consequences that could cause erroneous results.

The greatest advantage of multiple processes is that the generator separation is done automatically. A new generator for the test is created by the slave process in the exact same way that the generators are currently created.

The test suites are already designed so that only a specific test can be run when they are called. Adding the functionality needed to select a single test is trivial. Thus using processes only requires small changes in Testu01. This makes porting any future Testu01 improvements to the parallel implementation comparatively easier.

Furthermore, the process wrapper code can be written in a language other than C. Since it is not a time crucial part of the code, it can be written a higher level language such as Python, improving maintainability and extensibility.

Of course, processes have disadvantages of their own. The biggest one is the fact that the generator is set up separately for each process. This is explored further in the limitations section.

Extracting the test results from the processes will also have to be handled by the process master. Ideally they would be aggregated programmatically. Testu01 already provides this functionality and threads would be able to use it. Processes will not, so it will have to be duplicated by the process master.

Overall processes seem the better choice. Implementing them requires less time and debugging will be easier, both of which are very important under the time limitations for the project.

This was the most critical part of the design process. It had to be simplistic enough to be doable within the time limits and provide a working solution. If it were discovered near the final stages that this approach would not yield results, there would not be enough time for a second attempt. There was only time for one solution and the path to it had to guarantee results. The more sophisticated solutions by Suciu et al\cite{parallelism-paper2} would have been interesting to explore, but possibly would have not provided results. That was not a risk that could be taken.

Processes, although primitive in comparison to frameworks that would allow thread based decoupling of the generators, are easy to use and learn and would almost definitely provide a performance boost, at least for more primitive generators.

\subsection{Aggregating the results}
The original test suite prints out the results of each test right after it is finished. This is not the case with the parallel version.

The choice for the results of each test to be captured immediately was made, but processed and finished only once the whole suite is finished. This means that there is no indication the results until the very end. If the test suite were to be stopped no results could be obtained from the run.

This was done to maintain the same order printing order as the original suites. Printing the results in order earlier could only implemented with a thread and would require locking mechanisms to be placed.

This would not guarantee that the tests are printed close to the time that each test is completed. In order to uphold the test order, the results for the latter tests would have to be printed after the first tests of the suite are completed. If the earlier tests were ones of the last to be run in the parallel version, the results would only be printed then, thus presenting no significant advantage over waiting until the whole suite is complete. The benefits do not justify writing very complex and bug prone code.

More importantly, having a thread would impact performance. Waiting for the locked resources and the overhead from switching between the threads adds overhead and would definitely affect the performance.

\subsection{Process master-slave model}
A process based implementation requires a process master and a process slave. The process slaves are written in C.

Talk a bit about how the test number is passed to the process

\subsection{Processmaster Implementation Language}
Python was chosen as the implementation language due to a number of reasons. Probably the most important one is Python's portability. It is readily available in the platforms that Testu01 works and can handle multiprocessing in an OS agnostic way.

It is also easy to use and provides very useful tools that make interpreting the process results much easier than it would be in C. It was chosen over other similar languages such as Lua and Perl due to previous experience with it.

\subsection{Test Order}
In order to minimise the total time of the suite, the best order is to start the slowest tests first. Obviously the actual run time of the tests cannot be known a priori, but an estimation can be acquired.

Testu01 prints the total CPU time taken for each test. Using a simple generator a list of tests from slowest to fastest can be acquired. This will not be a representation of the actual times the tests will take since it will vary from generator to generator, but it will be good enough to sort the tests by run time.

This order will hold strictly if the generators add equal overhead to each test, which from reading the source of Testu01, seems to be the case. Even if the order is not strictly correct, it still is a good estimate.

Running the tests by order restricts the flexibility of the solution. If new tests are added, simply changing the number of tests in the definitions will not be enough, the will have to be added to the order file as well. This is not a problem as tools to automatically generate the order from a file that holds the output of the test suites are provided.

\section{Building Testu01}
\subsection{Vanilla Testu01}
The project was entirely developed and tested on Arch Linux. As such, Arch specific tools were used to automate the build and install process, the most important of which is makepkg.

Testu01 can be built using the conventional ./configure make make install process. This is useful for Linux distributions for which packages with precompiled binaries do not exist. 

This is not the case for Arch Linux as a script that automates the process is provided in the Arch Linux User Repository. This way Testu01 is also handled by the package manager. The process for building packages from the AUR is explained thoroughly in the Arch Wiki\cite{archwiki-aur} and only the important parts for building Testu01 will be repeated here.

After acquiring the Testu01 PKGBUILD from the AUR\cite{testu01-aur}, it can be installed with the following commands
\begin{verbatim}
makepkg -s
sudo pacman -U testu01-1.2.3-3-$(uname -m).pkg.tar.xz
\end{verbatim}

\subsection{Modified Testu01}
Building the customised version of Testu01 only requires small changes in the PKGBUILD file. The source had to be changed to point to the correct github repository and the package name had to be changed as well.

The only required changes are the following:
\begin{verbatim}
source=("git://github.com/rski/testu01-parallel")
#since the source is no longer an archive there is no checksum
sha256sums=('SKIP')
#ensure that installing it along testu01 will not happen
conflicts=('testu01')
\end{verbatim}

The full PKGBUILD file is part of the source on the github repository\cite{github-repo} and can be found under the \texttt{/build} folder.

\section{Running the test suites}
After installing Testu01, the first step was to run the test suites using one of the built in generators.

\section{Modifying Testu01}
\subsection{Testu01 structure}

\subsection{Modifications for parallelism}

\section{Test Order Generation}

\section{Handling the Processes}

\section{Result Processing}
